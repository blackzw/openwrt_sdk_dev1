// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_messages.proto

#ifndef PROTOBUF_system_5fmessages_2eproto__INCLUDED
#define PROTOBUF_system_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace SystemMessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_system_5fmessages_2eproto();
void protobuf_AssignDesc_system_5fmessages_2eproto();
void protobuf_ShutdownFile_system_5fmessages_2eproto();

class BLEquipmentInfo;
class BLDiagInfo;
class BLSystemCommon;
class BLModuleLinuxVer;
class BLSendCommandReq;
class BLSendCommandRes;
class BLFotaReport;
class BLSetFotaVal;
class BLGetImsiRes;

// ===================================================================

class BLEquipmentInfo : public ::google::protobuf::MessageLite {
 public:
  BLEquipmentInfo();
  virtual ~BLEquipmentInfo();
  
  BLEquipmentInfo(const BLEquipmentInfo& from);
  
  inline BLEquipmentInfo& operator=(const BLEquipmentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLEquipmentInfo& default_instance();
  
  void Swap(BLEquipmentInfo* other);
  
  // implements Message ----------------------------------------------
  
  BLEquipmentInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLEquipmentInfo& from);
  void MergeFrom(const BLEquipmentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strManufacturer = 1;
  inline bool has_strmanufacturer() const;
  inline void clear_strmanufacturer();
  static const int kStrManufacturerFieldNumber = 1;
  inline const ::std::string& strmanufacturer() const;
  inline void set_strmanufacturer(const ::std::string& value);
  inline void set_strmanufacturer(const char* value);
  inline void set_strmanufacturer(const char* value, size_t size);
  inline ::std::string* mutable_strmanufacturer();
  inline ::std::string* release_strmanufacturer();
  
  // required string strModel = 2;
  inline bool has_strmodel() const;
  inline void clear_strmodel();
  static const int kStrModelFieldNumber = 2;
  inline const ::std::string& strmodel() const;
  inline void set_strmodel(const ::std::string& value);
  inline void set_strmodel(const char* value);
  inline void set_strmodel(const char* value, size_t size);
  inline ::std::string* mutable_strmodel();
  inline ::std::string* release_strmodel();
  
  // required string strRevision = 3;
  inline bool has_strrevision() const;
  inline void clear_strrevision();
  static const int kStrRevisionFieldNumber = 3;
  inline const ::std::string& strrevision() const;
  inline void set_strrevision(const ::std::string& value);
  inline void set_strrevision(const char* value);
  inline void set_strrevision(const char* value, size_t size);
  inline ::std::string* mutable_strrevision();
  inline ::std::string* release_strrevision();
  
  // required string strSerialNumber = 4;
  inline bool has_strserialnumber() const;
  inline void clear_strserialnumber();
  static const int kStrSerialNumberFieldNumber = 4;
  inline const ::std::string& strserialnumber() const;
  inline void set_strserialnumber(const ::std::string& value);
  inline void set_strserialnumber(const char* value);
  inline void set_strserialnumber(const char* value, size_t size);
  inline ::std::string* mutable_strserialnumber();
  inline ::std::string* release_strserialnumber();
  
  // required string strCommercialSerialNumber = 5;
  inline bool has_strcommercialserialnumber() const;
  inline void clear_strcommercialserialnumber();
  static const int kStrCommercialSerialNumberFieldNumber = 5;
  inline const ::std::string& strcommercialserialnumber() const;
  inline void set_strcommercialserialnumber(const ::std::string& value);
  inline void set_strcommercialserialnumber(const char* value);
  inline void set_strcommercialserialnumber(const char* value, size_t size);
  inline ::std::string* mutable_strcommercialserialnumber();
  inline ::std::string* release_strcommercialserialnumber();
  
  // required string strImsi = 6;
  inline bool has_strimsi() const;
  inline void clear_strimsi();
  static const int kStrImsiFieldNumber = 6;
  inline const ::std::string& strimsi() const;
  inline void set_strimsi(const ::std::string& value);
  inline void set_strimsi(const char* value);
  inline void set_strimsi(const char* value, size_t size);
  inline ::std::string* mutable_strimsi();
  inline ::std::string* release_strimsi();
  
  // required string strMsisdn = 7;
  inline bool has_strmsisdn() const;
  inline void clear_strmsisdn();
  static const int kStrMsisdnFieldNumber = 7;
  inline const ::std::string& strmsisdn() const;
  inline void set_strmsisdn(const ::std::string& value);
  inline void set_strmsisdn(const char* value);
  inline void set_strmsisdn(const char* value, size_t size);
  inline ::std::string* mutable_strmsisdn();
  inline ::std::string* release_strmsisdn();
  
  // required string strHardwareVersion = 8;
  inline bool has_strhardwareversion() const;
  inline void clear_strhardwareversion();
  static const int kStrHardwareVersionFieldNumber = 8;
  inline const ::std::string& strhardwareversion() const;
  inline void set_strhardwareversion(const ::std::string& value);
  inline void set_strhardwareversion(const char* value);
  inline void set_strhardwareversion(const char* value, size_t size);
  inline ::std::string* mutable_strhardwareversion();
  inline ::std::string* release_strhardwareversion();
  
  // required string strQcn = 9;
  inline bool has_strqcn() const;
  inline void clear_strqcn();
  static const int kStrQcnFieldNumber = 9;
  inline const ::std::string& strqcn() const;
  inline void set_strqcn(const ::std::string& value);
  inline void set_strqcn(const char* value);
  inline void set_strqcn(const char* value, size_t size);
  inline ::std::string* mutable_strqcn();
  inline ::std::string* release_strqcn();
  
  // required string strExternalVer = 10;
  inline bool has_strexternalver() const;
  inline void clear_strexternalver();
  static const int kStrExternalVerFieldNumber = 10;
  inline const ::std::string& strexternalver() const;
  inline void set_strexternalver(const ::std::string& value);
  inline void set_strexternalver(const char* value);
  inline void set_strexternalver(const char* value, size_t size);
  inline ::std::string* mutable_strexternalver();
  inline ::std::string* release_strexternalver();
  
  // required int32 nLastErr = 11;
  inline bool has_nlasterr() const;
  inline void clear_nlasterr();
  static const int kNLastErrFieldNumber = 11;
  inline ::google::protobuf::int32 nlasterr() const;
  inline void set_nlasterr(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLEquipmentInfo)
 private:
  inline void set_has_strmanufacturer();
  inline void clear_has_strmanufacturer();
  inline void set_has_strmodel();
  inline void clear_has_strmodel();
  inline void set_has_strrevision();
  inline void clear_has_strrevision();
  inline void set_has_strserialnumber();
  inline void clear_has_strserialnumber();
  inline void set_has_strcommercialserialnumber();
  inline void clear_has_strcommercialserialnumber();
  inline void set_has_strimsi();
  inline void clear_has_strimsi();
  inline void set_has_strmsisdn();
  inline void clear_has_strmsisdn();
  inline void set_has_strhardwareversion();
  inline void clear_has_strhardwareversion();
  inline void set_has_strqcn();
  inline void clear_has_strqcn();
  inline void set_has_strexternalver();
  inline void clear_has_strexternalver();
  inline void set_has_nlasterr();
  inline void clear_has_nlasterr();
  
  ::std::string* strmanufacturer_;
  ::std::string* strmodel_;
  ::std::string* strrevision_;
  ::std::string* strserialnumber_;
  ::std::string* strcommercialserialnumber_;
  ::std::string* strimsi_;
  ::std::string* strmsisdn_;
  ::std::string* strhardwareversion_;
  ::std::string* strqcn_;
  ::std::string* strexternalver_;
  ::google::protobuf::int32 nlasterr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLEquipmentInfo* default_instance_;
};
// -------------------------------------------------------------------

class BLDiagInfo : public ::google::protobuf::MessageLite {
 public:
  BLDiagInfo();
  virtual ~BLDiagInfo();
  
  BLDiagInfo(const BLDiagInfo& from);
  
  inline BLDiagInfo& operator=(const BLDiagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLDiagInfo& default_instance();
  
  void Swap(BLDiagInfo* other);
  
  // implements Message ----------------------------------------------
  
  BLDiagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLDiagInfo& from);
  void MergeFrom(const BLDiagInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .SystemMessages.BLEquipmentInfo equipment_info = 1;
  inline bool has_equipment_info() const;
  inline void clear_equipment_info();
  static const int kEquipmentInfoFieldNumber = 1;
  inline const ::SystemMessages::BLEquipmentInfo& equipment_info() const;
  inline ::SystemMessages::BLEquipmentInfo* mutable_equipment_info();
  inline ::SystemMessages::BLEquipmentInfo* release_equipment_info();
  
  // required int32 nMode = 2;
  inline bool has_nmode() const;
  inline void clear_nmode();
  static const int kNModeFieldNumber = 2;
  inline ::google::protobuf::int32 nmode() const;
  inline void set_nmode(::google::protobuf::int32 value);
  
  // required int32 nFormat = 3;
  inline bool has_nformat() const;
  inline void clear_nformat();
  static const int kNFormatFieldNumber = 3;
  inline ::google::protobuf::int32 nformat() const;
  inline void set_nformat(::google::protobuf::int32 value);
  
  // required string strOperator = 4;
  inline bool has_stroperator() const;
  inline void clear_stroperator();
  static const int kStrOperatorFieldNumber = 4;
  inline const ::std::string& stroperator() const;
  inline void set_stroperator(const ::std::string& value);
  inline void set_stroperator(const char* value);
  inline void set_stroperator(const char* value, size_t size);
  inline ::std::string* mutable_stroperator();
  inline ::std::string* release_stroperator();
  
  // required int32 nAct = 5;
  inline bool has_nact() const;
  inline void clear_nact();
  static const int kNActFieldNumber = 5;
  inline ::google::protobuf::int32 nact() const;
  inline void set_nact(::google::protobuf::int32 value);
  
  // required bytes strSpName = 6;
  inline bool has_strspname() const;
  inline void clear_strspname();
  static const int kStrSpNameFieldNumber = 6;
  inline const ::std::string& strspname() const;
  inline void set_strspname(const ::std::string& value);
  inline void set_strspname(const char* value);
  inline void set_strspname(const void* value, size_t size);
  inline ::std::string* mutable_strspname();
  inline ::std::string* release_strspname();
  
  // required int32 nRssi = 7;
  inline bool has_nrssi() const;
  inline void clear_nrssi();
  static const int kNRssiFieldNumber = 7;
  inline ::google::protobuf::int32 nrssi() const;
  inline void set_nrssi(::google::protobuf::int32 value);
  
  // required int32 nDBRssi = 8;
  inline bool has_ndbrssi() const;
  inline void clear_ndbrssi();
  static const int kNDBRssiFieldNumber = 8;
  inline ::google::protobuf::int32 ndbrssi() const;
  inline void set_ndbrssi(::google::protobuf::int32 value);
  
  // required string strApplicationPort = 9;
  inline bool has_strapplicationport() const;
  inline void clear_strapplicationport();
  static const int kStrApplicationPortFieldNumber = 9;
  inline const ::std::string& strapplicationport() const;
  inline void set_strapplicationport(const ::std::string& value);
  inline void set_strapplicationport(const char* value);
  inline void set_strapplicationport(const char* value, size_t size);
  inline ::std::string* mutable_strapplicationport();
  inline ::std::string* release_strapplicationport();
  
  // required int32 nRoamState = 10;
  inline bool has_nroamstate() const;
  inline void clear_nroamstate();
  static const int kNRoamStateFieldNumber = 10;
  inline ::google::protobuf::int32 nroamstate() const;
  inline void set_nroamstate(::google::protobuf::int32 value);
  
  // required int32 nBearer = 11;
  inline bool has_nbearer() const;
  inline void clear_nbearer();
  static const int kNBearerFieldNumber = 11;
  inline ::google::protobuf::int32 nbearer() const;
  inline void set_nbearer(::google::protobuf::int32 value);
  
  // required int32 nPinState = 12;
  inline bool has_npinstate() const;
  inline void clear_npinstate();
  static const int kNPinStateFieldNumber = 12;
  inline ::google::protobuf::int32 npinstate() const;
  inline void set_npinstate(::google::protobuf::int32 value);
  
  // required int32 nGprsRegState = 13;
  inline bool has_ngprsregstate() const;
  inline void clear_ngprsregstate();
  static const int kNGprsRegStateFieldNumber = 13;
  inline ::google::protobuf::int32 ngprsregstate() const;
  inline void set_ngprsregstate(::google::protobuf::int32 value);
  
  // required int32 nNormalRegState = 14;
  inline bool has_nnormalregstate() const;
  inline void clear_nnormalregstate();
  static const int kNNormalRegStateFieldNumber = 14;
  inline ::google::protobuf::int32 nnormalregstate() const;
  inline void set_nnormalregstate(::google::protobuf::int32 value);
  
  // required int32 nPsAttachState = 15;
  inline bool has_npsattachstate() const;
  inline void clear_npsattachstate();
  static const int kNPsAttachStateFieldNumber = 15;
  inline ::google::protobuf::int32 npsattachstate() const;
  inline void set_npsattachstate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLDiagInfo)
 private:
  inline void set_has_equipment_info();
  inline void clear_has_equipment_info();
  inline void set_has_nmode();
  inline void clear_has_nmode();
  inline void set_has_nformat();
  inline void clear_has_nformat();
  inline void set_has_stroperator();
  inline void clear_has_stroperator();
  inline void set_has_nact();
  inline void clear_has_nact();
  inline void set_has_strspname();
  inline void clear_has_strspname();
  inline void set_has_nrssi();
  inline void clear_has_nrssi();
  inline void set_has_ndbrssi();
  inline void clear_has_ndbrssi();
  inline void set_has_strapplicationport();
  inline void clear_has_strapplicationport();
  inline void set_has_nroamstate();
  inline void clear_has_nroamstate();
  inline void set_has_nbearer();
  inline void clear_has_nbearer();
  inline void set_has_npinstate();
  inline void clear_has_npinstate();
  inline void set_has_ngprsregstate();
  inline void clear_has_ngprsregstate();
  inline void set_has_nnormalregstate();
  inline void clear_has_nnormalregstate();
  inline void set_has_npsattachstate();
  inline void clear_has_npsattachstate();
  
  ::SystemMessages::BLEquipmentInfo* equipment_info_;
  ::google::protobuf::int32 nmode_;
  ::google::protobuf::int32 nformat_;
  ::std::string* stroperator_;
  ::std::string* strspname_;
  ::google::protobuf::int32 nact_;
  ::google::protobuf::int32 nrssi_;
  ::std::string* strapplicationport_;
  ::google::protobuf::int32 ndbrssi_;
  ::google::protobuf::int32 nroamstate_;
  ::google::protobuf::int32 nbearer_;
  ::google::protobuf::int32 npinstate_;
  ::google::protobuf::int32 ngprsregstate_;
  ::google::protobuf::int32 nnormalregstate_;
  ::google::protobuf::int32 npsattachstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLDiagInfo* default_instance_;
};
// -------------------------------------------------------------------

class BLSystemCommon : public ::google::protobuf::MessageLite {
 public:
  BLSystemCommon();
  virtual ~BLSystemCommon();
  
  BLSystemCommon(const BLSystemCommon& from);
  
  inline BLSystemCommon& operator=(const BLSystemCommon& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLSystemCommon& default_instance();
  
  void Swap(BLSystemCommon* other);
  
  // implements Message ----------------------------------------------
  
  BLSystemCommon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLSystemCommon& from);
  void MergeFrom(const BLSystemCommon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string strMsisdn = 1;
  inline bool has_strmsisdn() const;
  inline void clear_strmsisdn();
  static const int kStrMsisdnFieldNumber = 1;
  inline const ::std::string& strmsisdn() const;
  inline void set_strmsisdn(const ::std::string& value);
  inline void set_strmsisdn(const char* value);
  inline void set_strmsisdn(const char* value, size_t size);
  inline ::std::string* mutable_strmsisdn();
  inline ::std::string* release_strmsisdn();
  
  // optional string strICCID = 2;
  inline bool has_striccid() const;
  inline void clear_striccid();
  static const int kStrICCIDFieldNumber = 2;
  inline const ::std::string& striccid() const;
  inline void set_striccid(const ::std::string& value);
  inline void set_striccid(const char* value);
  inline void set_striccid(const char* value, size_t size);
  inline ::std::string* mutable_striccid();
  inline ::std::string* release_striccid();
  
  // optional string strCUREF = 3;
  inline bool has_strcuref() const;
  inline void clear_strcuref();
  static const int kStrCUREFFieldNumber = 3;
  inline const ::std::string& strcuref() const;
  inline void set_strcuref(const ::std::string& value);
  inline void set_strcuref(const char* value);
  inline void set_strcuref(const char* value, size_t size);
  inline ::std::string* mutable_strcuref();
  inline ::std::string* release_strcuref();
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLSystemCommon)
 private:
  inline void set_has_strmsisdn();
  inline void clear_has_strmsisdn();
  inline void set_has_striccid();
  inline void clear_has_striccid();
  inline void set_has_strcuref();
  inline void clear_has_strcuref();
  
  ::std::string* strmsisdn_;
  ::std::string* striccid_;
  ::std::string* strcuref_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLSystemCommon* default_instance_;
};
// -------------------------------------------------------------------

class BLModuleLinuxVer : public ::google::protobuf::MessageLite {
 public:
  BLModuleLinuxVer();
  virtual ~BLModuleLinuxVer();
  
  BLModuleLinuxVer(const BLModuleLinuxVer& from);
  
  inline BLModuleLinuxVer& operator=(const BLModuleLinuxVer& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLModuleLinuxVer& default_instance();
  
  void Swap(BLModuleLinuxVer* other);
  
  // implements Message ----------------------------------------------
  
  BLModuleLinuxVer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLModuleLinuxVer& from);
  void MergeFrom(const BLModuleLinuxVer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strLinuxKer = 1;
  inline bool has_strlinuxker() const;
  inline void clear_strlinuxker();
  static const int kStrLinuxKerFieldNumber = 1;
  inline const ::std::string& strlinuxker() const;
  inline void set_strlinuxker(const ::std::string& value);
  inline void set_strlinuxker(const char* value);
  inline void set_strlinuxker(const char* value, size_t size);
  inline ::std::string* mutable_strlinuxker();
  inline ::std::string* release_strlinuxker();
  
  // required string strLinuxSys = 2;
  inline bool has_strlinuxsys() const;
  inline void clear_strlinuxsys();
  static const int kStrLinuxSysFieldNumber = 2;
  inline const ::std::string& strlinuxsys() const;
  inline void set_strlinuxsys(const ::std::string& value);
  inline void set_strlinuxsys(const char* value);
  inline void set_strlinuxsys(const char* value, size_t size);
  inline ::std::string* mutable_strlinuxsys();
  inline ::std::string* release_strlinuxsys();
  
  // required string strLinuxUser = 3;
  inline bool has_strlinuxuser() const;
  inline void clear_strlinuxuser();
  static const int kStrLinuxUserFieldNumber = 3;
  inline const ::std::string& strlinuxuser() const;
  inline void set_strlinuxuser(const ::std::string& value);
  inline void set_strlinuxuser(const char* value);
  inline void set_strlinuxuser(const char* value, size_t size);
  inline ::std::string* mutable_strlinuxuser();
  inline ::std::string* release_strlinuxuser();
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLModuleLinuxVer)
 private:
  inline void set_has_strlinuxker();
  inline void clear_has_strlinuxker();
  inline void set_has_strlinuxsys();
  inline void clear_has_strlinuxsys();
  inline void set_has_strlinuxuser();
  inline void clear_has_strlinuxuser();
  
  ::std::string* strlinuxker_;
  ::std::string* strlinuxsys_;
  ::std::string* strlinuxuser_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLModuleLinuxVer* default_instance_;
};
// -------------------------------------------------------------------

class BLSendCommandReq : public ::google::protobuf::MessageLite {
 public:
  BLSendCommandReq();
  virtual ~BLSendCommandReq();
  
  BLSendCommandReq(const BLSendCommandReq& from);
  
  inline BLSendCommandReq& operator=(const BLSendCommandReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLSendCommandReq& default_instance();
  
  void Swap(BLSendCommandReq* other);
  
  // implements Message ----------------------------------------------
  
  BLSendCommandReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLSendCommandReq& from);
  void MergeFrom(const BLSendCommandReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strCommand = 1;
  inline bool has_strcommand() const;
  inline void clear_strcommand();
  static const int kStrCommandFieldNumber = 1;
  inline const ::std::string& strcommand() const;
  inline void set_strcommand(const ::std::string& value);
  inline void set_strcommand(const char* value);
  inline void set_strcommand(const char* value, size_t size);
  inline ::std::string* mutable_strcommand();
  inline ::std::string* release_strcommand();
  
  // required int32 nTimeout = 2;
  inline bool has_ntimeout() const;
  inline void clear_ntimeout();
  static const int kNTimeoutFieldNumber = 2;
  inline ::google::protobuf::int32 ntimeout() const;
  inline void set_ntimeout(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLSendCommandReq)
 private:
  inline void set_has_strcommand();
  inline void clear_has_strcommand();
  inline void set_has_ntimeout();
  inline void clear_has_ntimeout();
  
  ::std::string* strcommand_;
  ::google::protobuf::int32 ntimeout_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLSendCommandReq* default_instance_;
};
// -------------------------------------------------------------------

class BLSendCommandRes : public ::google::protobuf::MessageLite {
 public:
  BLSendCommandRes();
  virtual ~BLSendCommandRes();
  
  BLSendCommandRes(const BLSendCommandRes& from);
  
  inline BLSendCommandRes& operator=(const BLSendCommandRes& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLSendCommandRes& default_instance();
  
  void Swap(BLSendCommandRes* other);
  
  // implements Message ----------------------------------------------
  
  BLSendCommandRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLSendCommandRes& from);
  void MergeFrom(const BLSendCommandRes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strResponse = 1;
  inline bool has_strresponse() const;
  inline void clear_strresponse();
  static const int kStrResponseFieldNumber = 1;
  inline const ::std::string& strresponse() const;
  inline void set_strresponse(const ::std::string& value);
  inline void set_strresponse(const char* value);
  inline void set_strresponse(const char* value, size_t size);
  inline ::std::string* mutable_strresponse();
  inline ::std::string* release_strresponse();
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLSendCommandRes)
 private:
  inline void set_has_strresponse();
  inline void clear_has_strresponse();
  
  ::std::string* strresponse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLSendCommandRes* default_instance_;
};
// -------------------------------------------------------------------

class BLFotaReport : public ::google::protobuf::MessageLite {
 public:
  BLFotaReport();
  virtual ~BLFotaReport();
  
  BLFotaReport(const BLFotaReport& from);
  
  inline BLFotaReport& operator=(const BLFotaReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLFotaReport& default_instance();
  
  void Swap(BLFotaReport* other);
  
  // implements Message ----------------------------------------------
  
  BLFotaReport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLFotaReport& from);
  void MergeFrom(const BLFotaReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 nStep = 1;
  inline bool has_nstep() const;
  inline void clear_nstep();
  static const int kNStepFieldNumber = 1;
  inline ::google::protobuf::int32 nstep() const;
  inline void set_nstep(::google::protobuf::int32 value);
  
  // required int32 nStatus = 2;
  inline bool has_nstatus() const;
  inline void clear_nstatus();
  static const int kNStatusFieldNumber = 2;
  inline ::google::protobuf::int32 nstatus() const;
  inline void set_nstatus(::google::protobuf::int32 value);
  
  // required int32 nInfo = 3;
  inline bool has_ninfo() const;
  inline void clear_ninfo();
  static const int kNInfoFieldNumber = 3;
  inline ::google::protobuf::int32 ninfo() const;
  inline void set_ninfo(::google::protobuf::int32 value);
  
  // optional int32 nMask = 4;
  inline bool has_nmask() const;
  inline void clear_nmask();
  static const int kNMaskFieldNumber = 4;
  inline ::google::protobuf::int32 nmask() const;
  inline void set_nmask(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLFotaReport)
 private:
  inline void set_has_nstep();
  inline void clear_has_nstep();
  inline void set_has_nstatus();
  inline void clear_has_nstatus();
  inline void set_has_ninfo();
  inline void clear_has_ninfo();
  inline void set_has_nmask();
  inline void clear_has_nmask();
  
  ::google::protobuf::int32 nstep_;
  ::google::protobuf::int32 nstatus_;
  ::google::protobuf::int32 ninfo_;
  ::google::protobuf::int32 nmask_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLFotaReport* default_instance_;
};
// -------------------------------------------------------------------

class BLSetFotaVal : public ::google::protobuf::MessageLite {
 public:
  BLSetFotaVal();
  virtual ~BLSetFotaVal();
  
  BLSetFotaVal(const BLSetFotaVal& from);
  
  inline BLSetFotaVal& operator=(const BLSetFotaVal& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLSetFotaVal& default_instance();
  
  void Swap(BLSetFotaVal* other);
  
  // implements Message ----------------------------------------------
  
  BLSetFotaVal* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLSetFotaVal& from);
  void MergeFrom(const BLSetFotaVal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 nStep = 1;
  inline bool has_nstep() const;
  inline void clear_nstep();
  static const int kNStepFieldNumber = 1;
  inline ::google::protobuf::int32 nstep() const;
  inline void set_nstep(::google::protobuf::int32 value);
  
  // required int32 nOperation = 2;
  inline bool has_noperation() const;
  inline void clear_noperation();
  static const int kNOperationFieldNumber = 2;
  inline ::google::protobuf::int32 noperation() const;
  inline void set_noperation(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLSetFotaVal)
 private:
  inline void set_has_nstep();
  inline void clear_has_nstep();
  inline void set_has_noperation();
  inline void clear_has_noperation();
  
  ::google::protobuf::int32 nstep_;
  ::google::protobuf::int32 noperation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLSetFotaVal* default_instance_;
};
// -------------------------------------------------------------------

class BLGetImsiRes : public ::google::protobuf::MessageLite {
 public:
  BLGetImsiRes();
  virtual ~BLGetImsiRes();
  
  BLGetImsiRes(const BLGetImsiRes& from);
  
  inline BLGetImsiRes& operator=(const BLGetImsiRes& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLGetImsiRes& default_instance();
  
  void Swap(BLGetImsiRes* other);
  
  // implements Message ----------------------------------------------
  
  BLGetImsiRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLGetImsiRes& from);
  void MergeFrom(const BLGetImsiRes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strImsi = 1;
  inline bool has_strimsi() const;
  inline void clear_strimsi();
  static const int kStrImsiFieldNumber = 1;
  inline const ::std::string& strimsi() const;
  inline void set_strimsi(const ::std::string& value);
  inline void set_strimsi(const char* value);
  inline void set_strimsi(const char* value, size_t size);
  inline ::std::string* mutable_strimsi();
  inline ::std::string* release_strimsi();
  
  // @@protoc_insertion_point(class_scope:SystemMessages.BLGetImsiRes)
 private:
  inline void set_has_strimsi();
  inline void clear_has_strimsi();
  
  ::std::string* strimsi_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_system_5fmessages_2eproto();
  friend void protobuf_AssignDesc_system_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_system_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLGetImsiRes* default_instance_;
};
// ===================================================================


// ===================================================================

// BLEquipmentInfo

// required string strManufacturer = 1;
inline bool BLEquipmentInfo::has_strmanufacturer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLEquipmentInfo::set_has_strmanufacturer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLEquipmentInfo::clear_has_strmanufacturer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLEquipmentInfo::clear_strmanufacturer() {
  if (strmanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    strmanufacturer_->clear();
  }
  clear_has_strmanufacturer();
}
inline const ::std::string& BLEquipmentInfo::strmanufacturer() const {
  return *strmanufacturer_;
}
inline void BLEquipmentInfo::set_strmanufacturer(const ::std::string& value) {
  set_has_strmanufacturer();
  if (strmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacturer_ = new ::std::string;
  }
  strmanufacturer_->assign(value);
}
inline void BLEquipmentInfo::set_strmanufacturer(const char* value) {
  set_has_strmanufacturer();
  if (strmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacturer_ = new ::std::string;
  }
  strmanufacturer_->assign(value);
}
inline void BLEquipmentInfo::set_strmanufacturer(const char* value, size_t size) {
  set_has_strmanufacturer();
  if (strmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacturer_ = new ::std::string;
  }
  strmanufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strmanufacturer() {
  set_has_strmanufacturer();
  if (strmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    strmanufacturer_ = new ::std::string;
  }
  return strmanufacturer_;
}
inline ::std::string* BLEquipmentInfo::release_strmanufacturer() {
  clear_has_strmanufacturer();
  if (strmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmanufacturer_;
    strmanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strModel = 2;
inline bool BLEquipmentInfo::has_strmodel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLEquipmentInfo::set_has_strmodel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLEquipmentInfo::clear_has_strmodel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLEquipmentInfo::clear_strmodel() {
  if (strmodel_ != &::google::protobuf::internal::kEmptyString) {
    strmodel_->clear();
  }
  clear_has_strmodel();
}
inline const ::std::string& BLEquipmentInfo::strmodel() const {
  return *strmodel_;
}
inline void BLEquipmentInfo::set_strmodel(const ::std::string& value) {
  set_has_strmodel();
  if (strmodel_ == &::google::protobuf::internal::kEmptyString) {
    strmodel_ = new ::std::string;
  }
  strmodel_->assign(value);
}
inline void BLEquipmentInfo::set_strmodel(const char* value) {
  set_has_strmodel();
  if (strmodel_ == &::google::protobuf::internal::kEmptyString) {
    strmodel_ = new ::std::string;
  }
  strmodel_->assign(value);
}
inline void BLEquipmentInfo::set_strmodel(const char* value, size_t size) {
  set_has_strmodel();
  if (strmodel_ == &::google::protobuf::internal::kEmptyString) {
    strmodel_ = new ::std::string;
  }
  strmodel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strmodel() {
  set_has_strmodel();
  if (strmodel_ == &::google::protobuf::internal::kEmptyString) {
    strmodel_ = new ::std::string;
  }
  return strmodel_;
}
inline ::std::string* BLEquipmentInfo::release_strmodel() {
  clear_has_strmodel();
  if (strmodel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmodel_;
    strmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strRevision = 3;
inline bool BLEquipmentInfo::has_strrevision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BLEquipmentInfo::set_has_strrevision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BLEquipmentInfo::clear_has_strrevision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BLEquipmentInfo::clear_strrevision() {
  if (strrevision_ != &::google::protobuf::internal::kEmptyString) {
    strrevision_->clear();
  }
  clear_has_strrevision();
}
inline const ::std::string& BLEquipmentInfo::strrevision() const {
  return *strrevision_;
}
inline void BLEquipmentInfo::set_strrevision(const ::std::string& value) {
  set_has_strrevision();
  if (strrevision_ == &::google::protobuf::internal::kEmptyString) {
    strrevision_ = new ::std::string;
  }
  strrevision_->assign(value);
}
inline void BLEquipmentInfo::set_strrevision(const char* value) {
  set_has_strrevision();
  if (strrevision_ == &::google::protobuf::internal::kEmptyString) {
    strrevision_ = new ::std::string;
  }
  strrevision_->assign(value);
}
inline void BLEquipmentInfo::set_strrevision(const char* value, size_t size) {
  set_has_strrevision();
  if (strrevision_ == &::google::protobuf::internal::kEmptyString) {
    strrevision_ = new ::std::string;
  }
  strrevision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strrevision() {
  set_has_strrevision();
  if (strrevision_ == &::google::protobuf::internal::kEmptyString) {
    strrevision_ = new ::std::string;
  }
  return strrevision_;
}
inline ::std::string* BLEquipmentInfo::release_strrevision() {
  clear_has_strrevision();
  if (strrevision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strrevision_;
    strrevision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strSerialNumber = 4;
inline bool BLEquipmentInfo::has_strserialnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BLEquipmentInfo::set_has_strserialnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BLEquipmentInfo::clear_has_strserialnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BLEquipmentInfo::clear_strserialnumber() {
  if (strserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    strserialnumber_->clear();
  }
  clear_has_strserialnumber();
}
inline const ::std::string& BLEquipmentInfo::strserialnumber() const {
  return *strserialnumber_;
}
inline void BLEquipmentInfo::set_strserialnumber(const ::std::string& value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void BLEquipmentInfo::set_strserialnumber(const char* value) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(value);
}
inline void BLEquipmentInfo::set_strserialnumber(const char* value, size_t size) {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  strserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strserialnumber() {
  set_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strserialnumber_ = new ::std::string;
  }
  return strserialnumber_;
}
inline ::std::string* BLEquipmentInfo::release_strserialnumber() {
  clear_has_strserialnumber();
  if (strserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strserialnumber_;
    strserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strCommercialSerialNumber = 5;
inline bool BLEquipmentInfo::has_strcommercialserialnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BLEquipmentInfo::set_has_strcommercialserialnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BLEquipmentInfo::clear_has_strcommercialserialnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BLEquipmentInfo::clear_strcommercialserialnumber() {
  if (strcommercialserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    strcommercialserialnumber_->clear();
  }
  clear_has_strcommercialserialnumber();
}
inline const ::std::string& BLEquipmentInfo::strcommercialserialnumber() const {
  return *strcommercialserialnumber_;
}
inline void BLEquipmentInfo::set_strcommercialserialnumber(const ::std::string& value) {
  set_has_strcommercialserialnumber();
  if (strcommercialserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcommercialserialnumber_ = new ::std::string;
  }
  strcommercialserialnumber_->assign(value);
}
inline void BLEquipmentInfo::set_strcommercialserialnumber(const char* value) {
  set_has_strcommercialserialnumber();
  if (strcommercialserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcommercialserialnumber_ = new ::std::string;
  }
  strcommercialserialnumber_->assign(value);
}
inline void BLEquipmentInfo::set_strcommercialserialnumber(const char* value, size_t size) {
  set_has_strcommercialserialnumber();
  if (strcommercialserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcommercialserialnumber_ = new ::std::string;
  }
  strcommercialserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strcommercialserialnumber() {
  set_has_strcommercialserialnumber();
  if (strcommercialserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    strcommercialserialnumber_ = new ::std::string;
  }
  return strcommercialserialnumber_;
}
inline ::std::string* BLEquipmentInfo::release_strcommercialserialnumber() {
  clear_has_strcommercialserialnumber();
  if (strcommercialserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcommercialserialnumber_;
    strcommercialserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strImsi = 6;
inline bool BLEquipmentInfo::has_strimsi() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BLEquipmentInfo::set_has_strimsi() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BLEquipmentInfo::clear_has_strimsi() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BLEquipmentInfo::clear_strimsi() {
  if (strimsi_ != &::google::protobuf::internal::kEmptyString) {
    strimsi_->clear();
  }
  clear_has_strimsi();
}
inline const ::std::string& BLEquipmentInfo::strimsi() const {
  return *strimsi_;
}
inline void BLEquipmentInfo::set_strimsi(const ::std::string& value) {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  strimsi_->assign(value);
}
inline void BLEquipmentInfo::set_strimsi(const char* value) {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  strimsi_->assign(value);
}
inline void BLEquipmentInfo::set_strimsi(const char* value, size_t size) {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  strimsi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strimsi() {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  return strimsi_;
}
inline ::std::string* BLEquipmentInfo::release_strimsi() {
  clear_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strimsi_;
    strimsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strMsisdn = 7;
inline bool BLEquipmentInfo::has_strmsisdn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BLEquipmentInfo::set_has_strmsisdn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BLEquipmentInfo::clear_has_strmsisdn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BLEquipmentInfo::clear_strmsisdn() {
  if (strmsisdn_ != &::google::protobuf::internal::kEmptyString) {
    strmsisdn_->clear();
  }
  clear_has_strmsisdn();
}
inline const ::std::string& BLEquipmentInfo::strmsisdn() const {
  return *strmsisdn_;
}
inline void BLEquipmentInfo::set_strmsisdn(const ::std::string& value) {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  strmsisdn_->assign(value);
}
inline void BLEquipmentInfo::set_strmsisdn(const char* value) {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  strmsisdn_->assign(value);
}
inline void BLEquipmentInfo::set_strmsisdn(const char* value, size_t size) {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  strmsisdn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strmsisdn() {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  return strmsisdn_;
}
inline ::std::string* BLEquipmentInfo::release_strmsisdn() {
  clear_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmsisdn_;
    strmsisdn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strHardwareVersion = 8;
inline bool BLEquipmentInfo::has_strhardwareversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BLEquipmentInfo::set_has_strhardwareversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BLEquipmentInfo::clear_has_strhardwareversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BLEquipmentInfo::clear_strhardwareversion() {
  if (strhardwareversion_ != &::google::protobuf::internal::kEmptyString) {
    strhardwareversion_->clear();
  }
  clear_has_strhardwareversion();
}
inline const ::std::string& BLEquipmentInfo::strhardwareversion() const {
  return *strhardwareversion_;
}
inline void BLEquipmentInfo::set_strhardwareversion(const ::std::string& value) {
  set_has_strhardwareversion();
  if (strhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    strhardwareversion_ = new ::std::string;
  }
  strhardwareversion_->assign(value);
}
inline void BLEquipmentInfo::set_strhardwareversion(const char* value) {
  set_has_strhardwareversion();
  if (strhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    strhardwareversion_ = new ::std::string;
  }
  strhardwareversion_->assign(value);
}
inline void BLEquipmentInfo::set_strhardwareversion(const char* value, size_t size) {
  set_has_strhardwareversion();
  if (strhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    strhardwareversion_ = new ::std::string;
  }
  strhardwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strhardwareversion() {
  set_has_strhardwareversion();
  if (strhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    strhardwareversion_ = new ::std::string;
  }
  return strhardwareversion_;
}
inline ::std::string* BLEquipmentInfo::release_strhardwareversion() {
  clear_has_strhardwareversion();
  if (strhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strhardwareversion_;
    strhardwareversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strQcn = 9;
inline bool BLEquipmentInfo::has_strqcn() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BLEquipmentInfo::set_has_strqcn() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BLEquipmentInfo::clear_has_strqcn() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BLEquipmentInfo::clear_strqcn() {
  if (strqcn_ != &::google::protobuf::internal::kEmptyString) {
    strqcn_->clear();
  }
  clear_has_strqcn();
}
inline const ::std::string& BLEquipmentInfo::strqcn() const {
  return *strqcn_;
}
inline void BLEquipmentInfo::set_strqcn(const ::std::string& value) {
  set_has_strqcn();
  if (strqcn_ == &::google::protobuf::internal::kEmptyString) {
    strqcn_ = new ::std::string;
  }
  strqcn_->assign(value);
}
inline void BLEquipmentInfo::set_strqcn(const char* value) {
  set_has_strqcn();
  if (strqcn_ == &::google::protobuf::internal::kEmptyString) {
    strqcn_ = new ::std::string;
  }
  strqcn_->assign(value);
}
inline void BLEquipmentInfo::set_strqcn(const char* value, size_t size) {
  set_has_strqcn();
  if (strqcn_ == &::google::protobuf::internal::kEmptyString) {
    strqcn_ = new ::std::string;
  }
  strqcn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strqcn() {
  set_has_strqcn();
  if (strqcn_ == &::google::protobuf::internal::kEmptyString) {
    strqcn_ = new ::std::string;
  }
  return strqcn_;
}
inline ::std::string* BLEquipmentInfo::release_strqcn() {
  clear_has_strqcn();
  if (strqcn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strqcn_;
    strqcn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strExternalVer = 10;
inline bool BLEquipmentInfo::has_strexternalver() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BLEquipmentInfo::set_has_strexternalver() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BLEquipmentInfo::clear_has_strexternalver() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BLEquipmentInfo::clear_strexternalver() {
  if (strexternalver_ != &::google::protobuf::internal::kEmptyString) {
    strexternalver_->clear();
  }
  clear_has_strexternalver();
}
inline const ::std::string& BLEquipmentInfo::strexternalver() const {
  return *strexternalver_;
}
inline void BLEquipmentInfo::set_strexternalver(const ::std::string& value) {
  set_has_strexternalver();
  if (strexternalver_ == &::google::protobuf::internal::kEmptyString) {
    strexternalver_ = new ::std::string;
  }
  strexternalver_->assign(value);
}
inline void BLEquipmentInfo::set_strexternalver(const char* value) {
  set_has_strexternalver();
  if (strexternalver_ == &::google::protobuf::internal::kEmptyString) {
    strexternalver_ = new ::std::string;
  }
  strexternalver_->assign(value);
}
inline void BLEquipmentInfo::set_strexternalver(const char* value, size_t size) {
  set_has_strexternalver();
  if (strexternalver_ == &::google::protobuf::internal::kEmptyString) {
    strexternalver_ = new ::std::string;
  }
  strexternalver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLEquipmentInfo::mutable_strexternalver() {
  set_has_strexternalver();
  if (strexternalver_ == &::google::protobuf::internal::kEmptyString) {
    strexternalver_ = new ::std::string;
  }
  return strexternalver_;
}
inline ::std::string* BLEquipmentInfo::release_strexternalver() {
  clear_has_strexternalver();
  if (strexternalver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strexternalver_;
    strexternalver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 nLastErr = 11;
inline bool BLEquipmentInfo::has_nlasterr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BLEquipmentInfo::set_has_nlasterr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BLEquipmentInfo::clear_has_nlasterr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BLEquipmentInfo::clear_nlasterr() {
  nlasterr_ = 0;
  clear_has_nlasterr();
}
inline ::google::protobuf::int32 BLEquipmentInfo::nlasterr() const {
  return nlasterr_;
}
inline void BLEquipmentInfo::set_nlasterr(::google::protobuf::int32 value) {
  set_has_nlasterr();
  nlasterr_ = value;
}

// -------------------------------------------------------------------

// BLDiagInfo

// required .SystemMessages.BLEquipmentInfo equipment_info = 1;
inline bool BLDiagInfo::has_equipment_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLDiagInfo::set_has_equipment_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLDiagInfo::clear_has_equipment_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLDiagInfo::clear_equipment_info() {
  if (equipment_info_ != NULL) equipment_info_->::SystemMessages::BLEquipmentInfo::Clear();
  clear_has_equipment_info();
}
inline const ::SystemMessages::BLEquipmentInfo& BLDiagInfo::equipment_info() const {
  return equipment_info_ != NULL ? *equipment_info_ : *default_instance_->equipment_info_;
}
inline ::SystemMessages::BLEquipmentInfo* BLDiagInfo::mutable_equipment_info() {
  set_has_equipment_info();
  if (equipment_info_ == NULL) equipment_info_ = new ::SystemMessages::BLEquipmentInfo;
  return equipment_info_;
}
inline ::SystemMessages::BLEquipmentInfo* BLDiagInfo::release_equipment_info() {
  clear_has_equipment_info();
  ::SystemMessages::BLEquipmentInfo* temp = equipment_info_;
  equipment_info_ = NULL;
  return temp;
}

// required int32 nMode = 2;
inline bool BLDiagInfo::has_nmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLDiagInfo::set_has_nmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLDiagInfo::clear_has_nmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLDiagInfo::clear_nmode() {
  nmode_ = 0;
  clear_has_nmode();
}
inline ::google::protobuf::int32 BLDiagInfo::nmode() const {
  return nmode_;
}
inline void BLDiagInfo::set_nmode(::google::protobuf::int32 value) {
  set_has_nmode();
  nmode_ = value;
}

// required int32 nFormat = 3;
inline bool BLDiagInfo::has_nformat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BLDiagInfo::set_has_nformat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BLDiagInfo::clear_has_nformat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BLDiagInfo::clear_nformat() {
  nformat_ = 0;
  clear_has_nformat();
}
inline ::google::protobuf::int32 BLDiagInfo::nformat() const {
  return nformat_;
}
inline void BLDiagInfo::set_nformat(::google::protobuf::int32 value) {
  set_has_nformat();
  nformat_ = value;
}

// required string strOperator = 4;
inline bool BLDiagInfo::has_stroperator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BLDiagInfo::set_has_stroperator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BLDiagInfo::clear_has_stroperator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BLDiagInfo::clear_stroperator() {
  if (stroperator_ != &::google::protobuf::internal::kEmptyString) {
    stroperator_->clear();
  }
  clear_has_stroperator();
}
inline const ::std::string& BLDiagInfo::stroperator() const {
  return *stroperator_;
}
inline void BLDiagInfo::set_stroperator(const ::std::string& value) {
  set_has_stroperator();
  if (stroperator_ == &::google::protobuf::internal::kEmptyString) {
    stroperator_ = new ::std::string;
  }
  stroperator_->assign(value);
}
inline void BLDiagInfo::set_stroperator(const char* value) {
  set_has_stroperator();
  if (stroperator_ == &::google::protobuf::internal::kEmptyString) {
    stroperator_ = new ::std::string;
  }
  stroperator_->assign(value);
}
inline void BLDiagInfo::set_stroperator(const char* value, size_t size) {
  set_has_stroperator();
  if (stroperator_ == &::google::protobuf::internal::kEmptyString) {
    stroperator_ = new ::std::string;
  }
  stroperator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLDiagInfo::mutable_stroperator() {
  set_has_stroperator();
  if (stroperator_ == &::google::protobuf::internal::kEmptyString) {
    stroperator_ = new ::std::string;
  }
  return stroperator_;
}
inline ::std::string* BLDiagInfo::release_stroperator() {
  clear_has_stroperator();
  if (stroperator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroperator_;
    stroperator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 nAct = 5;
inline bool BLDiagInfo::has_nact() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BLDiagInfo::set_has_nact() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BLDiagInfo::clear_has_nact() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BLDiagInfo::clear_nact() {
  nact_ = 0;
  clear_has_nact();
}
inline ::google::protobuf::int32 BLDiagInfo::nact() const {
  return nact_;
}
inline void BLDiagInfo::set_nact(::google::protobuf::int32 value) {
  set_has_nact();
  nact_ = value;
}

// required bytes strSpName = 6;
inline bool BLDiagInfo::has_strspname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BLDiagInfo::set_has_strspname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BLDiagInfo::clear_has_strspname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BLDiagInfo::clear_strspname() {
  if (strspname_ != &::google::protobuf::internal::kEmptyString) {
    strspname_->clear();
  }
  clear_has_strspname();
}
inline const ::std::string& BLDiagInfo::strspname() const {
  return *strspname_;
}
inline void BLDiagInfo::set_strspname(const ::std::string& value) {
  set_has_strspname();
  if (strspname_ == &::google::protobuf::internal::kEmptyString) {
    strspname_ = new ::std::string;
  }
  strspname_->assign(value);
}
inline void BLDiagInfo::set_strspname(const char* value) {
  set_has_strspname();
  if (strspname_ == &::google::protobuf::internal::kEmptyString) {
    strspname_ = new ::std::string;
  }
  strspname_->assign(value);
}
inline void BLDiagInfo::set_strspname(const void* value, size_t size) {
  set_has_strspname();
  if (strspname_ == &::google::protobuf::internal::kEmptyString) {
    strspname_ = new ::std::string;
  }
  strspname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLDiagInfo::mutable_strspname() {
  set_has_strspname();
  if (strspname_ == &::google::protobuf::internal::kEmptyString) {
    strspname_ = new ::std::string;
  }
  return strspname_;
}
inline ::std::string* BLDiagInfo::release_strspname() {
  clear_has_strspname();
  if (strspname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strspname_;
    strspname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 nRssi = 7;
inline bool BLDiagInfo::has_nrssi() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BLDiagInfo::set_has_nrssi() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BLDiagInfo::clear_has_nrssi() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BLDiagInfo::clear_nrssi() {
  nrssi_ = 0;
  clear_has_nrssi();
}
inline ::google::protobuf::int32 BLDiagInfo::nrssi() const {
  return nrssi_;
}
inline void BLDiagInfo::set_nrssi(::google::protobuf::int32 value) {
  set_has_nrssi();
  nrssi_ = value;
}

// required int32 nDBRssi = 8;
inline bool BLDiagInfo::has_ndbrssi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BLDiagInfo::set_has_ndbrssi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BLDiagInfo::clear_has_ndbrssi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BLDiagInfo::clear_ndbrssi() {
  ndbrssi_ = 0;
  clear_has_ndbrssi();
}
inline ::google::protobuf::int32 BLDiagInfo::ndbrssi() const {
  return ndbrssi_;
}
inline void BLDiagInfo::set_ndbrssi(::google::protobuf::int32 value) {
  set_has_ndbrssi();
  ndbrssi_ = value;
}

// required string strApplicationPort = 9;
inline bool BLDiagInfo::has_strapplicationport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BLDiagInfo::set_has_strapplicationport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BLDiagInfo::clear_has_strapplicationport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BLDiagInfo::clear_strapplicationport() {
  if (strapplicationport_ != &::google::protobuf::internal::kEmptyString) {
    strapplicationport_->clear();
  }
  clear_has_strapplicationport();
}
inline const ::std::string& BLDiagInfo::strapplicationport() const {
  return *strapplicationport_;
}
inline void BLDiagInfo::set_strapplicationport(const ::std::string& value) {
  set_has_strapplicationport();
  if (strapplicationport_ == &::google::protobuf::internal::kEmptyString) {
    strapplicationport_ = new ::std::string;
  }
  strapplicationport_->assign(value);
}
inline void BLDiagInfo::set_strapplicationport(const char* value) {
  set_has_strapplicationport();
  if (strapplicationport_ == &::google::protobuf::internal::kEmptyString) {
    strapplicationport_ = new ::std::string;
  }
  strapplicationport_->assign(value);
}
inline void BLDiagInfo::set_strapplicationport(const char* value, size_t size) {
  set_has_strapplicationport();
  if (strapplicationport_ == &::google::protobuf::internal::kEmptyString) {
    strapplicationport_ = new ::std::string;
  }
  strapplicationport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLDiagInfo::mutable_strapplicationport() {
  set_has_strapplicationport();
  if (strapplicationport_ == &::google::protobuf::internal::kEmptyString) {
    strapplicationport_ = new ::std::string;
  }
  return strapplicationport_;
}
inline ::std::string* BLDiagInfo::release_strapplicationport() {
  clear_has_strapplicationport();
  if (strapplicationport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strapplicationport_;
    strapplicationport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 nRoamState = 10;
inline bool BLDiagInfo::has_nroamstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BLDiagInfo::set_has_nroamstate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BLDiagInfo::clear_has_nroamstate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BLDiagInfo::clear_nroamstate() {
  nroamstate_ = 0;
  clear_has_nroamstate();
}
inline ::google::protobuf::int32 BLDiagInfo::nroamstate() const {
  return nroamstate_;
}
inline void BLDiagInfo::set_nroamstate(::google::protobuf::int32 value) {
  set_has_nroamstate();
  nroamstate_ = value;
}

// required int32 nBearer = 11;
inline bool BLDiagInfo::has_nbearer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BLDiagInfo::set_has_nbearer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BLDiagInfo::clear_has_nbearer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BLDiagInfo::clear_nbearer() {
  nbearer_ = 0;
  clear_has_nbearer();
}
inline ::google::protobuf::int32 BLDiagInfo::nbearer() const {
  return nbearer_;
}
inline void BLDiagInfo::set_nbearer(::google::protobuf::int32 value) {
  set_has_nbearer();
  nbearer_ = value;
}

// required int32 nPinState = 12;
inline bool BLDiagInfo::has_npinstate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BLDiagInfo::set_has_npinstate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BLDiagInfo::clear_has_npinstate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BLDiagInfo::clear_npinstate() {
  npinstate_ = 0;
  clear_has_npinstate();
}
inline ::google::protobuf::int32 BLDiagInfo::npinstate() const {
  return npinstate_;
}
inline void BLDiagInfo::set_npinstate(::google::protobuf::int32 value) {
  set_has_npinstate();
  npinstate_ = value;
}

// required int32 nGprsRegState = 13;
inline bool BLDiagInfo::has_ngprsregstate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BLDiagInfo::set_has_ngprsregstate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BLDiagInfo::clear_has_ngprsregstate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BLDiagInfo::clear_ngprsregstate() {
  ngprsregstate_ = 0;
  clear_has_ngprsregstate();
}
inline ::google::protobuf::int32 BLDiagInfo::ngprsregstate() const {
  return ngprsregstate_;
}
inline void BLDiagInfo::set_ngprsregstate(::google::protobuf::int32 value) {
  set_has_ngprsregstate();
  ngprsregstate_ = value;
}

// required int32 nNormalRegState = 14;
inline bool BLDiagInfo::has_nnormalregstate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BLDiagInfo::set_has_nnormalregstate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BLDiagInfo::clear_has_nnormalregstate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BLDiagInfo::clear_nnormalregstate() {
  nnormalregstate_ = 0;
  clear_has_nnormalregstate();
}
inline ::google::protobuf::int32 BLDiagInfo::nnormalregstate() const {
  return nnormalregstate_;
}
inline void BLDiagInfo::set_nnormalregstate(::google::protobuf::int32 value) {
  set_has_nnormalregstate();
  nnormalregstate_ = value;
}

// required int32 nPsAttachState = 15;
inline bool BLDiagInfo::has_npsattachstate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BLDiagInfo::set_has_npsattachstate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BLDiagInfo::clear_has_npsattachstate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BLDiagInfo::clear_npsattachstate() {
  npsattachstate_ = 0;
  clear_has_npsattachstate();
}
inline ::google::protobuf::int32 BLDiagInfo::npsattachstate() const {
  return npsattachstate_;
}
inline void BLDiagInfo::set_npsattachstate(::google::protobuf::int32 value) {
  set_has_npsattachstate();
  npsattachstate_ = value;
}

// -------------------------------------------------------------------

// BLSystemCommon

// optional string strMsisdn = 1;
inline bool BLSystemCommon::has_strmsisdn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLSystemCommon::set_has_strmsisdn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLSystemCommon::clear_has_strmsisdn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLSystemCommon::clear_strmsisdn() {
  if (strmsisdn_ != &::google::protobuf::internal::kEmptyString) {
    strmsisdn_->clear();
  }
  clear_has_strmsisdn();
}
inline const ::std::string& BLSystemCommon::strmsisdn() const {
  return *strmsisdn_;
}
inline void BLSystemCommon::set_strmsisdn(const ::std::string& value) {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  strmsisdn_->assign(value);
}
inline void BLSystemCommon::set_strmsisdn(const char* value) {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  strmsisdn_->assign(value);
}
inline void BLSystemCommon::set_strmsisdn(const char* value, size_t size) {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  strmsisdn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLSystemCommon::mutable_strmsisdn() {
  set_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    strmsisdn_ = new ::std::string;
  }
  return strmsisdn_;
}
inline ::std::string* BLSystemCommon::release_strmsisdn() {
  clear_has_strmsisdn();
  if (strmsisdn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strmsisdn_;
    strmsisdn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strICCID = 2;
inline bool BLSystemCommon::has_striccid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLSystemCommon::set_has_striccid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLSystemCommon::clear_has_striccid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLSystemCommon::clear_striccid() {
  if (striccid_ != &::google::protobuf::internal::kEmptyString) {
    striccid_->clear();
  }
  clear_has_striccid();
}
inline const ::std::string& BLSystemCommon::striccid() const {
  return *striccid_;
}
inline void BLSystemCommon::set_striccid(const ::std::string& value) {
  set_has_striccid();
  if (striccid_ == &::google::protobuf::internal::kEmptyString) {
    striccid_ = new ::std::string;
  }
  striccid_->assign(value);
}
inline void BLSystemCommon::set_striccid(const char* value) {
  set_has_striccid();
  if (striccid_ == &::google::protobuf::internal::kEmptyString) {
    striccid_ = new ::std::string;
  }
  striccid_->assign(value);
}
inline void BLSystemCommon::set_striccid(const char* value, size_t size) {
  set_has_striccid();
  if (striccid_ == &::google::protobuf::internal::kEmptyString) {
    striccid_ = new ::std::string;
  }
  striccid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLSystemCommon::mutable_striccid() {
  set_has_striccid();
  if (striccid_ == &::google::protobuf::internal::kEmptyString) {
    striccid_ = new ::std::string;
  }
  return striccid_;
}
inline ::std::string* BLSystemCommon::release_striccid() {
  clear_has_striccid();
  if (striccid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = striccid_;
    striccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strCUREF = 3;
inline bool BLSystemCommon::has_strcuref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BLSystemCommon::set_has_strcuref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BLSystemCommon::clear_has_strcuref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BLSystemCommon::clear_strcuref() {
  if (strcuref_ != &::google::protobuf::internal::kEmptyString) {
    strcuref_->clear();
  }
  clear_has_strcuref();
}
inline const ::std::string& BLSystemCommon::strcuref() const {
  return *strcuref_;
}
inline void BLSystemCommon::set_strcuref(const ::std::string& value) {
  set_has_strcuref();
  if (strcuref_ == &::google::protobuf::internal::kEmptyString) {
    strcuref_ = new ::std::string;
  }
  strcuref_->assign(value);
}
inline void BLSystemCommon::set_strcuref(const char* value) {
  set_has_strcuref();
  if (strcuref_ == &::google::protobuf::internal::kEmptyString) {
    strcuref_ = new ::std::string;
  }
  strcuref_->assign(value);
}
inline void BLSystemCommon::set_strcuref(const char* value, size_t size) {
  set_has_strcuref();
  if (strcuref_ == &::google::protobuf::internal::kEmptyString) {
    strcuref_ = new ::std::string;
  }
  strcuref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLSystemCommon::mutable_strcuref() {
  set_has_strcuref();
  if (strcuref_ == &::google::protobuf::internal::kEmptyString) {
    strcuref_ = new ::std::string;
  }
  return strcuref_;
}
inline ::std::string* BLSystemCommon::release_strcuref() {
  clear_has_strcuref();
  if (strcuref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcuref_;
    strcuref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLModuleLinuxVer

// required string strLinuxKer = 1;
inline bool BLModuleLinuxVer::has_strlinuxker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLModuleLinuxVer::set_has_strlinuxker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLModuleLinuxVer::clear_has_strlinuxker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLModuleLinuxVer::clear_strlinuxker() {
  if (strlinuxker_ != &::google::protobuf::internal::kEmptyString) {
    strlinuxker_->clear();
  }
  clear_has_strlinuxker();
}
inline const ::std::string& BLModuleLinuxVer::strlinuxker() const {
  return *strlinuxker_;
}
inline void BLModuleLinuxVer::set_strlinuxker(const ::std::string& value) {
  set_has_strlinuxker();
  if (strlinuxker_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxker_ = new ::std::string;
  }
  strlinuxker_->assign(value);
}
inline void BLModuleLinuxVer::set_strlinuxker(const char* value) {
  set_has_strlinuxker();
  if (strlinuxker_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxker_ = new ::std::string;
  }
  strlinuxker_->assign(value);
}
inline void BLModuleLinuxVer::set_strlinuxker(const char* value, size_t size) {
  set_has_strlinuxker();
  if (strlinuxker_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxker_ = new ::std::string;
  }
  strlinuxker_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLModuleLinuxVer::mutable_strlinuxker() {
  set_has_strlinuxker();
  if (strlinuxker_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxker_ = new ::std::string;
  }
  return strlinuxker_;
}
inline ::std::string* BLModuleLinuxVer::release_strlinuxker() {
  clear_has_strlinuxker();
  if (strlinuxker_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlinuxker_;
    strlinuxker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strLinuxSys = 2;
inline bool BLModuleLinuxVer::has_strlinuxsys() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLModuleLinuxVer::set_has_strlinuxsys() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLModuleLinuxVer::clear_has_strlinuxsys() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLModuleLinuxVer::clear_strlinuxsys() {
  if (strlinuxsys_ != &::google::protobuf::internal::kEmptyString) {
    strlinuxsys_->clear();
  }
  clear_has_strlinuxsys();
}
inline const ::std::string& BLModuleLinuxVer::strlinuxsys() const {
  return *strlinuxsys_;
}
inline void BLModuleLinuxVer::set_strlinuxsys(const ::std::string& value) {
  set_has_strlinuxsys();
  if (strlinuxsys_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxsys_ = new ::std::string;
  }
  strlinuxsys_->assign(value);
}
inline void BLModuleLinuxVer::set_strlinuxsys(const char* value) {
  set_has_strlinuxsys();
  if (strlinuxsys_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxsys_ = new ::std::string;
  }
  strlinuxsys_->assign(value);
}
inline void BLModuleLinuxVer::set_strlinuxsys(const char* value, size_t size) {
  set_has_strlinuxsys();
  if (strlinuxsys_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxsys_ = new ::std::string;
  }
  strlinuxsys_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLModuleLinuxVer::mutable_strlinuxsys() {
  set_has_strlinuxsys();
  if (strlinuxsys_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxsys_ = new ::std::string;
  }
  return strlinuxsys_;
}
inline ::std::string* BLModuleLinuxVer::release_strlinuxsys() {
  clear_has_strlinuxsys();
  if (strlinuxsys_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlinuxsys_;
    strlinuxsys_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strLinuxUser = 3;
inline bool BLModuleLinuxVer::has_strlinuxuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BLModuleLinuxVer::set_has_strlinuxuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BLModuleLinuxVer::clear_has_strlinuxuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BLModuleLinuxVer::clear_strlinuxuser() {
  if (strlinuxuser_ != &::google::protobuf::internal::kEmptyString) {
    strlinuxuser_->clear();
  }
  clear_has_strlinuxuser();
}
inline const ::std::string& BLModuleLinuxVer::strlinuxuser() const {
  return *strlinuxuser_;
}
inline void BLModuleLinuxVer::set_strlinuxuser(const ::std::string& value) {
  set_has_strlinuxuser();
  if (strlinuxuser_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxuser_ = new ::std::string;
  }
  strlinuxuser_->assign(value);
}
inline void BLModuleLinuxVer::set_strlinuxuser(const char* value) {
  set_has_strlinuxuser();
  if (strlinuxuser_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxuser_ = new ::std::string;
  }
  strlinuxuser_->assign(value);
}
inline void BLModuleLinuxVer::set_strlinuxuser(const char* value, size_t size) {
  set_has_strlinuxuser();
  if (strlinuxuser_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxuser_ = new ::std::string;
  }
  strlinuxuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLModuleLinuxVer::mutable_strlinuxuser() {
  set_has_strlinuxuser();
  if (strlinuxuser_ == &::google::protobuf::internal::kEmptyString) {
    strlinuxuser_ = new ::std::string;
  }
  return strlinuxuser_;
}
inline ::std::string* BLModuleLinuxVer::release_strlinuxuser() {
  clear_has_strlinuxuser();
  if (strlinuxuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strlinuxuser_;
    strlinuxuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLSendCommandReq

// required string strCommand = 1;
inline bool BLSendCommandReq::has_strcommand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLSendCommandReq::set_has_strcommand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLSendCommandReq::clear_has_strcommand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLSendCommandReq::clear_strcommand() {
  if (strcommand_ != &::google::protobuf::internal::kEmptyString) {
    strcommand_->clear();
  }
  clear_has_strcommand();
}
inline const ::std::string& BLSendCommandReq::strcommand() const {
  return *strcommand_;
}
inline void BLSendCommandReq::set_strcommand(const ::std::string& value) {
  set_has_strcommand();
  if (strcommand_ == &::google::protobuf::internal::kEmptyString) {
    strcommand_ = new ::std::string;
  }
  strcommand_->assign(value);
}
inline void BLSendCommandReq::set_strcommand(const char* value) {
  set_has_strcommand();
  if (strcommand_ == &::google::protobuf::internal::kEmptyString) {
    strcommand_ = new ::std::string;
  }
  strcommand_->assign(value);
}
inline void BLSendCommandReq::set_strcommand(const char* value, size_t size) {
  set_has_strcommand();
  if (strcommand_ == &::google::protobuf::internal::kEmptyString) {
    strcommand_ = new ::std::string;
  }
  strcommand_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLSendCommandReq::mutable_strcommand() {
  set_has_strcommand();
  if (strcommand_ == &::google::protobuf::internal::kEmptyString) {
    strcommand_ = new ::std::string;
  }
  return strcommand_;
}
inline ::std::string* BLSendCommandReq::release_strcommand() {
  clear_has_strcommand();
  if (strcommand_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strcommand_;
    strcommand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 nTimeout = 2;
inline bool BLSendCommandReq::has_ntimeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLSendCommandReq::set_has_ntimeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLSendCommandReq::clear_has_ntimeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLSendCommandReq::clear_ntimeout() {
  ntimeout_ = 0;
  clear_has_ntimeout();
}
inline ::google::protobuf::int32 BLSendCommandReq::ntimeout() const {
  return ntimeout_;
}
inline void BLSendCommandReq::set_ntimeout(::google::protobuf::int32 value) {
  set_has_ntimeout();
  ntimeout_ = value;
}

// -------------------------------------------------------------------

// BLSendCommandRes

// required string strResponse = 1;
inline bool BLSendCommandRes::has_strresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLSendCommandRes::set_has_strresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLSendCommandRes::clear_has_strresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLSendCommandRes::clear_strresponse() {
  if (strresponse_ != &::google::protobuf::internal::kEmptyString) {
    strresponse_->clear();
  }
  clear_has_strresponse();
}
inline const ::std::string& BLSendCommandRes::strresponse() const {
  return *strresponse_;
}
inline void BLSendCommandRes::set_strresponse(const ::std::string& value) {
  set_has_strresponse();
  if (strresponse_ == &::google::protobuf::internal::kEmptyString) {
    strresponse_ = new ::std::string;
  }
  strresponse_->assign(value);
}
inline void BLSendCommandRes::set_strresponse(const char* value) {
  set_has_strresponse();
  if (strresponse_ == &::google::protobuf::internal::kEmptyString) {
    strresponse_ = new ::std::string;
  }
  strresponse_->assign(value);
}
inline void BLSendCommandRes::set_strresponse(const char* value, size_t size) {
  set_has_strresponse();
  if (strresponse_ == &::google::protobuf::internal::kEmptyString) {
    strresponse_ = new ::std::string;
  }
  strresponse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLSendCommandRes::mutable_strresponse() {
  set_has_strresponse();
  if (strresponse_ == &::google::protobuf::internal::kEmptyString) {
    strresponse_ = new ::std::string;
  }
  return strresponse_;
}
inline ::std::string* BLSendCommandRes::release_strresponse() {
  clear_has_strresponse();
  if (strresponse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strresponse_;
    strresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLFotaReport

// required int32 nStep = 1;
inline bool BLFotaReport::has_nstep() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLFotaReport::set_has_nstep() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLFotaReport::clear_has_nstep() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLFotaReport::clear_nstep() {
  nstep_ = 0;
  clear_has_nstep();
}
inline ::google::protobuf::int32 BLFotaReport::nstep() const {
  return nstep_;
}
inline void BLFotaReport::set_nstep(::google::protobuf::int32 value) {
  set_has_nstep();
  nstep_ = value;
}

// required int32 nStatus = 2;
inline bool BLFotaReport::has_nstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLFotaReport::set_has_nstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLFotaReport::clear_has_nstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLFotaReport::clear_nstatus() {
  nstatus_ = 0;
  clear_has_nstatus();
}
inline ::google::protobuf::int32 BLFotaReport::nstatus() const {
  return nstatus_;
}
inline void BLFotaReport::set_nstatus(::google::protobuf::int32 value) {
  set_has_nstatus();
  nstatus_ = value;
}

// required int32 nInfo = 3;
inline bool BLFotaReport::has_ninfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BLFotaReport::set_has_ninfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BLFotaReport::clear_has_ninfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BLFotaReport::clear_ninfo() {
  ninfo_ = 0;
  clear_has_ninfo();
}
inline ::google::protobuf::int32 BLFotaReport::ninfo() const {
  return ninfo_;
}
inline void BLFotaReport::set_ninfo(::google::protobuf::int32 value) {
  set_has_ninfo();
  ninfo_ = value;
}

// optional int32 nMask = 4;
inline bool BLFotaReport::has_nmask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BLFotaReport::set_has_nmask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BLFotaReport::clear_has_nmask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BLFotaReport::clear_nmask() {
  nmask_ = 0;
  clear_has_nmask();
}
inline ::google::protobuf::int32 BLFotaReport::nmask() const {
  return nmask_;
}
inline void BLFotaReport::set_nmask(::google::protobuf::int32 value) {
  set_has_nmask();
  nmask_ = value;
}

// -------------------------------------------------------------------

// BLSetFotaVal

// required int32 nStep = 1;
inline bool BLSetFotaVal::has_nstep() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLSetFotaVal::set_has_nstep() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLSetFotaVal::clear_has_nstep() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLSetFotaVal::clear_nstep() {
  nstep_ = 0;
  clear_has_nstep();
}
inline ::google::protobuf::int32 BLSetFotaVal::nstep() const {
  return nstep_;
}
inline void BLSetFotaVal::set_nstep(::google::protobuf::int32 value) {
  set_has_nstep();
  nstep_ = value;
}

// required int32 nOperation = 2;
inline bool BLSetFotaVal::has_noperation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLSetFotaVal::set_has_noperation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLSetFotaVal::clear_has_noperation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLSetFotaVal::clear_noperation() {
  noperation_ = 0;
  clear_has_noperation();
}
inline ::google::protobuf::int32 BLSetFotaVal::noperation() const {
  return noperation_;
}
inline void BLSetFotaVal::set_noperation(::google::protobuf::int32 value) {
  set_has_noperation();
  noperation_ = value;
}

// -------------------------------------------------------------------

// BLGetImsiRes

// required string strImsi = 1;
inline bool BLGetImsiRes::has_strimsi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLGetImsiRes::set_has_strimsi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLGetImsiRes::clear_has_strimsi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLGetImsiRes::clear_strimsi() {
  if (strimsi_ != &::google::protobuf::internal::kEmptyString) {
    strimsi_->clear();
  }
  clear_has_strimsi();
}
inline const ::std::string& BLGetImsiRes::strimsi() const {
  return *strimsi_;
}
inline void BLGetImsiRes::set_strimsi(const ::std::string& value) {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  strimsi_->assign(value);
}
inline void BLGetImsiRes::set_strimsi(const char* value) {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  strimsi_->assign(value);
}
inline void BLGetImsiRes::set_strimsi(const char* value, size_t size) {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  strimsi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLGetImsiRes::mutable_strimsi() {
  set_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    strimsi_ = new ::std::string;
  }
  return strimsi_;
}
inline ::std::string* BLGetImsiRes::release_strimsi() {
  clear_has_strimsi();
  if (strimsi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strimsi_;
    strimsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SystemMessages

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_system_5fmessages_2eproto__INCLUDED
