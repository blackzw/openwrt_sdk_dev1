// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pin_messages.proto

#ifndef PROTOBUF_pin_5fmessages_2eproto__INCLUDED
#define PROTOBUF_pin_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace PinMessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pin_5fmessages_2eproto();
void protobuf_AssignDesc_pin_5fmessages_2eproto();
void protobuf_ShutdownFile_pin_5fmessages_2eproto();

class BLPinState;
class BLPinEnableReq;
class BLPinChangeReq;
class BLPinVerifyPukReq;
class BLPinVerifyReq;
class BLPinCommonRes;
class BLPinGetAutoValidateStateRes;
class BLPinSetAutoValidateStateReq;

// ===================================================================

class BLPinState : public ::google::protobuf::MessageLite {
 public:
  BLPinState();
  virtual ~BLPinState();
  
  BLPinState(const BLPinState& from);
  
  inline BLPinState& operator=(const BLPinState& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinState& default_instance();
  
  void Swap(BLPinState* other);
  
  // implements Message ----------------------------------------------
  
  BLPinState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinState& from);
  void MergeFrom(const BLPinState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 nState = 1 [default = 0];
  inline bool has_nstate() const;
  inline void clear_nstate();
  static const int kNStateFieldNumber = 1;
  inline ::google::protobuf::int32 nstate() const;
  inline void set_nstate(::google::protobuf::int32 value);
  
  // required int32 nPinCnt = 2 [default = 0];
  inline bool has_npincnt() const;
  inline void clear_npincnt();
  static const int kNPinCntFieldNumber = 2;
  inline ::google::protobuf::int32 npincnt() const;
  inline void set_npincnt(::google::protobuf::int32 value);
  
  // required int32 nPukCnt = 3 [default = 0];
  inline bool has_npukcnt() const;
  inline void clear_npukcnt();
  static const int kNPukCntFieldNumber = 3;
  inline ::google::protobuf::int32 npukcnt() const;
  inline void set_npukcnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinState)
 private:
  inline void set_has_nstate();
  inline void clear_has_nstate();
  inline void set_has_npincnt();
  inline void clear_has_npincnt();
  inline void set_has_npukcnt();
  inline void clear_has_npukcnt();
  
  ::google::protobuf::int32 nstate_;
  ::google::protobuf::int32 npincnt_;
  ::google::protobuf::int32 npukcnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinState* default_instance_;
};
// -------------------------------------------------------------------

class BLPinEnableReq : public ::google::protobuf::MessageLite {
 public:
  BLPinEnableReq();
  virtual ~BLPinEnableReq();
  
  BLPinEnableReq(const BLPinEnableReq& from);
  
  inline BLPinEnableReq& operator=(const BLPinEnableReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinEnableReq& default_instance();
  
  void Swap(BLPinEnableReq* other);
  
  // implements Message ----------------------------------------------
  
  BLPinEnableReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinEnableReq& from);
  void MergeFrom(const BLPinEnableReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool blPinEnable = 1;
  inline bool has_blpinenable() const;
  inline void clear_blpinenable();
  static const int kBlPinEnableFieldNumber = 1;
  inline bool blpinenable() const;
  inline void set_blpinenable(bool value);
  
  // required string strPinCode = 2;
  inline bool has_strpincode() const;
  inline void clear_strpincode();
  static const int kStrPinCodeFieldNumber = 2;
  inline const ::std::string& strpincode() const;
  inline void set_strpincode(const ::std::string& value);
  inline void set_strpincode(const char* value);
  inline void set_strpincode(const char* value, size_t size);
  inline ::std::string* mutable_strpincode();
  inline ::std::string* release_strpincode();
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinEnableReq)
 private:
  inline void set_has_blpinenable();
  inline void clear_has_blpinenable();
  inline void set_has_strpincode();
  inline void clear_has_strpincode();
  
  ::std::string* strpincode_;
  bool blpinenable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinEnableReq* default_instance_;
};
// -------------------------------------------------------------------

class BLPinChangeReq : public ::google::protobuf::MessageLite {
 public:
  BLPinChangeReq();
  virtual ~BLPinChangeReq();
  
  BLPinChangeReq(const BLPinChangeReq& from);
  
  inline BLPinChangeReq& operator=(const BLPinChangeReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinChangeReq& default_instance();
  
  void Swap(BLPinChangeReq* other);
  
  // implements Message ----------------------------------------------
  
  BLPinChangeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinChangeReq& from);
  void MergeFrom(const BLPinChangeReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strOldPin = 1;
  inline bool has_stroldpin() const;
  inline void clear_stroldpin();
  static const int kStrOldPinFieldNumber = 1;
  inline const ::std::string& stroldpin() const;
  inline void set_stroldpin(const ::std::string& value);
  inline void set_stroldpin(const char* value);
  inline void set_stroldpin(const char* value, size_t size);
  inline ::std::string* mutable_stroldpin();
  inline ::std::string* release_stroldpin();
  
  // required string strNewPin = 2;
  inline bool has_strnewpin() const;
  inline void clear_strnewpin();
  static const int kStrNewPinFieldNumber = 2;
  inline const ::std::string& strnewpin() const;
  inline void set_strnewpin(const ::std::string& value);
  inline void set_strnewpin(const char* value);
  inline void set_strnewpin(const char* value, size_t size);
  inline ::std::string* mutable_strnewpin();
  inline ::std::string* release_strnewpin();
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinChangeReq)
 private:
  inline void set_has_stroldpin();
  inline void clear_has_stroldpin();
  inline void set_has_strnewpin();
  inline void clear_has_strnewpin();
  
  ::std::string* stroldpin_;
  ::std::string* strnewpin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinChangeReq* default_instance_;
};
// -------------------------------------------------------------------

class BLPinVerifyPukReq : public ::google::protobuf::MessageLite {
 public:
  BLPinVerifyPukReq();
  virtual ~BLPinVerifyPukReq();
  
  BLPinVerifyPukReq(const BLPinVerifyPukReq& from);
  
  inline BLPinVerifyPukReq& operator=(const BLPinVerifyPukReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinVerifyPukReq& default_instance();
  
  void Swap(BLPinVerifyPukReq* other);
  
  // implements Message ----------------------------------------------
  
  BLPinVerifyPukReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinVerifyPukReq& from);
  void MergeFrom(const BLPinVerifyPukReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strPUK = 1;
  inline bool has_strpuk() const;
  inline void clear_strpuk();
  static const int kStrPUKFieldNumber = 1;
  inline const ::std::string& strpuk() const;
  inline void set_strpuk(const ::std::string& value);
  inline void set_strpuk(const char* value);
  inline void set_strpuk(const char* value, size_t size);
  inline ::std::string* mutable_strpuk();
  inline ::std::string* release_strpuk();
  
  // required string strNewPin = 2;
  inline bool has_strnewpin() const;
  inline void clear_strnewpin();
  static const int kStrNewPinFieldNumber = 2;
  inline const ::std::string& strnewpin() const;
  inline void set_strnewpin(const ::std::string& value);
  inline void set_strnewpin(const char* value);
  inline void set_strnewpin(const char* value, size_t size);
  inline ::std::string* mutable_strnewpin();
  inline ::std::string* release_strnewpin();
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinVerifyPukReq)
 private:
  inline void set_has_strpuk();
  inline void clear_has_strpuk();
  inline void set_has_strnewpin();
  inline void clear_has_strnewpin();
  
  ::std::string* strpuk_;
  ::std::string* strnewpin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinVerifyPukReq* default_instance_;
};
// -------------------------------------------------------------------

class BLPinVerifyReq : public ::google::protobuf::MessageLite {
 public:
  BLPinVerifyReq();
  virtual ~BLPinVerifyReq();
  
  BLPinVerifyReq(const BLPinVerifyReq& from);
  
  inline BLPinVerifyReq& operator=(const BLPinVerifyReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinVerifyReq& default_instance();
  
  void Swap(BLPinVerifyReq* other);
  
  // implements Message ----------------------------------------------
  
  BLPinVerifyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinVerifyReq& from);
  void MergeFrom(const BLPinVerifyReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string strPin = 1;
  inline bool has_strpin() const;
  inline void clear_strpin();
  static const int kStrPinFieldNumber = 1;
  inline const ::std::string& strpin() const;
  inline void set_strpin(const ::std::string& value);
  inline void set_strpin(const char* value);
  inline void set_strpin(const char* value, size_t size);
  inline ::std::string* mutable_strpin();
  inline ::std::string* release_strpin();
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinVerifyReq)
 private:
  inline void set_has_strpin();
  inline void clear_has_strpin();
  
  ::std::string* strpin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinVerifyReq* default_instance_;
};
// -------------------------------------------------------------------

class BLPinCommonRes : public ::google::protobuf::MessageLite {
 public:
  BLPinCommonRes();
  virtual ~BLPinCommonRes();
  
  BLPinCommonRes(const BLPinCommonRes& from);
  
  inline BLPinCommonRes& operator=(const BLPinCommonRes& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinCommonRes& default_instance();
  
  void Swap(BLPinCommonRes* other);
  
  // implements Message ----------------------------------------------
  
  BLPinCommonRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinCommonRes& from);
  void MergeFrom(const BLPinCommonRes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 nState = 1 [default = 0];
  inline bool has_nstate() const;
  inline void clear_nstate();
  static const int kNStateFieldNumber = 1;
  inline ::google::protobuf::int32 nstate() const;
  inline void set_nstate(::google::protobuf::int32 value);
  
  // optional bool bEnable = 2;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 2;
  inline bool benable() const;
  inline void set_benable(bool value);
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinCommonRes)
 private:
  inline void set_has_nstate();
  inline void clear_has_nstate();
  inline void set_has_benable();
  inline void clear_has_benable();
  
  ::google::protobuf::int32 nstate_;
  bool benable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinCommonRes* default_instance_;
};
// -------------------------------------------------------------------

class BLPinGetAutoValidateStateRes : public ::google::protobuf::MessageLite {
 public:
  BLPinGetAutoValidateStateRes();
  virtual ~BLPinGetAutoValidateStateRes();
  
  BLPinGetAutoValidateStateRes(const BLPinGetAutoValidateStateRes& from);
  
  inline BLPinGetAutoValidateStateRes& operator=(const BLPinGetAutoValidateStateRes& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinGetAutoValidateStateRes& default_instance();
  
  void Swap(BLPinGetAutoValidateStateRes* other);
  
  // implements Message ----------------------------------------------
  
  BLPinGetAutoValidateStateRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinGetAutoValidateStateRes& from);
  void MergeFrom(const BLPinGetAutoValidateStateRes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 nState = 1;
  inline bool has_nstate() const;
  inline void clear_nstate();
  static const int kNStateFieldNumber = 1;
  inline ::google::protobuf::int32 nstate() const;
  inline void set_nstate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinGetAutoValidateStateRes)
 private:
  inline void set_has_nstate();
  inline void clear_has_nstate();
  
  ::google::protobuf::int32 nstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinGetAutoValidateStateRes* default_instance_;
};
// -------------------------------------------------------------------

class BLPinSetAutoValidateStateReq : public ::google::protobuf::MessageLite {
 public:
  BLPinSetAutoValidateStateReq();
  virtual ~BLPinSetAutoValidateStateReq();
  
  BLPinSetAutoValidateStateReq(const BLPinSetAutoValidateStateReq& from);
  
  inline BLPinSetAutoValidateStateReq& operator=(const BLPinSetAutoValidateStateReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BLPinSetAutoValidateStateReq& default_instance();
  
  void Swap(BLPinSetAutoValidateStateReq* other);
  
  // implements Message ----------------------------------------------
  
  BLPinSetAutoValidateStateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BLPinSetAutoValidateStateReq& from);
  void MergeFrom(const BLPinSetAutoValidateStateReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 nState = 1;
  inline bool has_nstate() const;
  inline void clear_nstate();
  static const int kNStateFieldNumber = 1;
  inline ::google::protobuf::int32 nstate() const;
  inline void set_nstate(::google::protobuf::int32 value);
  
  // required string strPin = 2;
  inline bool has_strpin() const;
  inline void clear_strpin();
  static const int kStrPinFieldNumber = 2;
  inline const ::std::string& strpin() const;
  inline void set_strpin(const ::std::string& value);
  inline void set_strpin(const char* value);
  inline void set_strpin(const char* value, size_t size);
  inline ::std::string* mutable_strpin();
  inline ::std::string* release_strpin();
  
  // @@protoc_insertion_point(class_scope:PinMessages.BLPinSetAutoValidateStateReq)
 private:
  inline void set_has_nstate();
  inline void clear_has_nstate();
  inline void set_has_strpin();
  inline void clear_has_strpin();
  
  ::std::string* strpin_;
  ::google::protobuf::int32 nstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_pin_5fmessages_2eproto();
  friend void protobuf_AssignDesc_pin_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_pin_5fmessages_2eproto();
  
  void InitAsDefaultInstance();
  static BLPinSetAutoValidateStateReq* default_instance_;
};
// ===================================================================


// ===================================================================

// BLPinState

// required int32 nState = 1 [default = 0];
inline bool BLPinState::has_nstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinState::set_has_nstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinState::clear_has_nstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinState::clear_nstate() {
  nstate_ = 0;
  clear_has_nstate();
}
inline ::google::protobuf::int32 BLPinState::nstate() const {
  return nstate_;
}
inline void BLPinState::set_nstate(::google::protobuf::int32 value) {
  set_has_nstate();
  nstate_ = value;
}

// required int32 nPinCnt = 2 [default = 0];
inline bool BLPinState::has_npincnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLPinState::set_has_npincnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLPinState::clear_has_npincnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLPinState::clear_npincnt() {
  npincnt_ = 0;
  clear_has_npincnt();
}
inline ::google::protobuf::int32 BLPinState::npincnt() const {
  return npincnt_;
}
inline void BLPinState::set_npincnt(::google::protobuf::int32 value) {
  set_has_npincnt();
  npincnt_ = value;
}

// required int32 nPukCnt = 3 [default = 0];
inline bool BLPinState::has_npukcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BLPinState::set_has_npukcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BLPinState::clear_has_npukcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BLPinState::clear_npukcnt() {
  npukcnt_ = 0;
  clear_has_npukcnt();
}
inline ::google::protobuf::int32 BLPinState::npukcnt() const {
  return npukcnt_;
}
inline void BLPinState::set_npukcnt(::google::protobuf::int32 value) {
  set_has_npukcnt();
  npukcnt_ = value;
}

// -------------------------------------------------------------------

// BLPinEnableReq

// required bool blPinEnable = 1;
inline bool BLPinEnableReq::has_blpinenable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinEnableReq::set_has_blpinenable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinEnableReq::clear_has_blpinenable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinEnableReq::clear_blpinenable() {
  blpinenable_ = false;
  clear_has_blpinenable();
}
inline bool BLPinEnableReq::blpinenable() const {
  return blpinenable_;
}
inline void BLPinEnableReq::set_blpinenable(bool value) {
  set_has_blpinenable();
  blpinenable_ = value;
}

// required string strPinCode = 2;
inline bool BLPinEnableReq::has_strpincode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLPinEnableReq::set_has_strpincode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLPinEnableReq::clear_has_strpincode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLPinEnableReq::clear_strpincode() {
  if (strpincode_ != &::google::protobuf::internal::kEmptyString) {
    strpincode_->clear();
  }
  clear_has_strpincode();
}
inline const ::std::string& BLPinEnableReq::strpincode() const {
  return *strpincode_;
}
inline void BLPinEnableReq::set_strpincode(const ::std::string& value) {
  set_has_strpincode();
  if (strpincode_ == &::google::protobuf::internal::kEmptyString) {
    strpincode_ = new ::std::string;
  }
  strpincode_->assign(value);
}
inline void BLPinEnableReq::set_strpincode(const char* value) {
  set_has_strpincode();
  if (strpincode_ == &::google::protobuf::internal::kEmptyString) {
    strpincode_ = new ::std::string;
  }
  strpincode_->assign(value);
}
inline void BLPinEnableReq::set_strpincode(const char* value, size_t size) {
  set_has_strpincode();
  if (strpincode_ == &::google::protobuf::internal::kEmptyString) {
    strpincode_ = new ::std::string;
  }
  strpincode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinEnableReq::mutable_strpincode() {
  set_has_strpincode();
  if (strpincode_ == &::google::protobuf::internal::kEmptyString) {
    strpincode_ = new ::std::string;
  }
  return strpincode_;
}
inline ::std::string* BLPinEnableReq::release_strpincode() {
  clear_has_strpincode();
  if (strpincode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpincode_;
    strpincode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLPinChangeReq

// required string strOldPin = 1;
inline bool BLPinChangeReq::has_stroldpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinChangeReq::set_has_stroldpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinChangeReq::clear_has_stroldpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinChangeReq::clear_stroldpin() {
  if (stroldpin_ != &::google::protobuf::internal::kEmptyString) {
    stroldpin_->clear();
  }
  clear_has_stroldpin();
}
inline const ::std::string& BLPinChangeReq::stroldpin() const {
  return *stroldpin_;
}
inline void BLPinChangeReq::set_stroldpin(const ::std::string& value) {
  set_has_stroldpin();
  if (stroldpin_ == &::google::protobuf::internal::kEmptyString) {
    stroldpin_ = new ::std::string;
  }
  stroldpin_->assign(value);
}
inline void BLPinChangeReq::set_stroldpin(const char* value) {
  set_has_stroldpin();
  if (stroldpin_ == &::google::protobuf::internal::kEmptyString) {
    stroldpin_ = new ::std::string;
  }
  stroldpin_->assign(value);
}
inline void BLPinChangeReq::set_stroldpin(const char* value, size_t size) {
  set_has_stroldpin();
  if (stroldpin_ == &::google::protobuf::internal::kEmptyString) {
    stroldpin_ = new ::std::string;
  }
  stroldpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinChangeReq::mutable_stroldpin() {
  set_has_stroldpin();
  if (stroldpin_ == &::google::protobuf::internal::kEmptyString) {
    stroldpin_ = new ::std::string;
  }
  return stroldpin_;
}
inline ::std::string* BLPinChangeReq::release_stroldpin() {
  clear_has_stroldpin();
  if (stroldpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stroldpin_;
    stroldpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strNewPin = 2;
inline bool BLPinChangeReq::has_strnewpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLPinChangeReq::set_has_strnewpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLPinChangeReq::clear_has_strnewpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLPinChangeReq::clear_strnewpin() {
  if (strnewpin_ != &::google::protobuf::internal::kEmptyString) {
    strnewpin_->clear();
  }
  clear_has_strnewpin();
}
inline const ::std::string& BLPinChangeReq::strnewpin() const {
  return *strnewpin_;
}
inline void BLPinChangeReq::set_strnewpin(const ::std::string& value) {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  strnewpin_->assign(value);
}
inline void BLPinChangeReq::set_strnewpin(const char* value) {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  strnewpin_->assign(value);
}
inline void BLPinChangeReq::set_strnewpin(const char* value, size_t size) {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  strnewpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinChangeReq::mutable_strnewpin() {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  return strnewpin_;
}
inline ::std::string* BLPinChangeReq::release_strnewpin() {
  clear_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnewpin_;
    strnewpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLPinVerifyPukReq

// required string strPUK = 1;
inline bool BLPinVerifyPukReq::has_strpuk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinVerifyPukReq::set_has_strpuk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinVerifyPukReq::clear_has_strpuk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinVerifyPukReq::clear_strpuk() {
  if (strpuk_ != &::google::protobuf::internal::kEmptyString) {
    strpuk_->clear();
  }
  clear_has_strpuk();
}
inline const ::std::string& BLPinVerifyPukReq::strpuk() const {
  return *strpuk_;
}
inline void BLPinVerifyPukReq::set_strpuk(const ::std::string& value) {
  set_has_strpuk();
  if (strpuk_ == &::google::protobuf::internal::kEmptyString) {
    strpuk_ = new ::std::string;
  }
  strpuk_->assign(value);
}
inline void BLPinVerifyPukReq::set_strpuk(const char* value) {
  set_has_strpuk();
  if (strpuk_ == &::google::protobuf::internal::kEmptyString) {
    strpuk_ = new ::std::string;
  }
  strpuk_->assign(value);
}
inline void BLPinVerifyPukReq::set_strpuk(const char* value, size_t size) {
  set_has_strpuk();
  if (strpuk_ == &::google::protobuf::internal::kEmptyString) {
    strpuk_ = new ::std::string;
  }
  strpuk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinVerifyPukReq::mutable_strpuk() {
  set_has_strpuk();
  if (strpuk_ == &::google::protobuf::internal::kEmptyString) {
    strpuk_ = new ::std::string;
  }
  return strpuk_;
}
inline ::std::string* BLPinVerifyPukReq::release_strpuk() {
  clear_has_strpuk();
  if (strpuk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpuk_;
    strpuk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string strNewPin = 2;
inline bool BLPinVerifyPukReq::has_strnewpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLPinVerifyPukReq::set_has_strnewpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLPinVerifyPukReq::clear_has_strnewpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLPinVerifyPukReq::clear_strnewpin() {
  if (strnewpin_ != &::google::protobuf::internal::kEmptyString) {
    strnewpin_->clear();
  }
  clear_has_strnewpin();
}
inline const ::std::string& BLPinVerifyPukReq::strnewpin() const {
  return *strnewpin_;
}
inline void BLPinVerifyPukReq::set_strnewpin(const ::std::string& value) {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  strnewpin_->assign(value);
}
inline void BLPinVerifyPukReq::set_strnewpin(const char* value) {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  strnewpin_->assign(value);
}
inline void BLPinVerifyPukReq::set_strnewpin(const char* value, size_t size) {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  strnewpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinVerifyPukReq::mutable_strnewpin() {
  set_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    strnewpin_ = new ::std::string;
  }
  return strnewpin_;
}
inline ::std::string* BLPinVerifyPukReq::release_strnewpin() {
  clear_has_strnewpin();
  if (strnewpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strnewpin_;
    strnewpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLPinVerifyReq

// required string strPin = 1;
inline bool BLPinVerifyReq::has_strpin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinVerifyReq::set_has_strpin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinVerifyReq::clear_has_strpin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinVerifyReq::clear_strpin() {
  if (strpin_ != &::google::protobuf::internal::kEmptyString) {
    strpin_->clear();
  }
  clear_has_strpin();
}
inline const ::std::string& BLPinVerifyReq::strpin() const {
  return *strpin_;
}
inline void BLPinVerifyReq::set_strpin(const ::std::string& value) {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  strpin_->assign(value);
}
inline void BLPinVerifyReq::set_strpin(const char* value) {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  strpin_->assign(value);
}
inline void BLPinVerifyReq::set_strpin(const char* value, size_t size) {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  strpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinVerifyReq::mutable_strpin() {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  return strpin_;
}
inline ::std::string* BLPinVerifyReq::release_strpin() {
  clear_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpin_;
    strpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BLPinCommonRes

// optional int32 nState = 1 [default = 0];
inline bool BLPinCommonRes::has_nstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinCommonRes::set_has_nstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinCommonRes::clear_has_nstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinCommonRes::clear_nstate() {
  nstate_ = 0;
  clear_has_nstate();
}
inline ::google::protobuf::int32 BLPinCommonRes::nstate() const {
  return nstate_;
}
inline void BLPinCommonRes::set_nstate(::google::protobuf::int32 value) {
  set_has_nstate();
  nstate_ = value;
}

// optional bool bEnable = 2;
inline bool BLPinCommonRes::has_benable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLPinCommonRes::set_has_benable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLPinCommonRes::clear_has_benable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLPinCommonRes::clear_benable() {
  benable_ = false;
  clear_has_benable();
}
inline bool BLPinCommonRes::benable() const {
  return benable_;
}
inline void BLPinCommonRes::set_benable(bool value) {
  set_has_benable();
  benable_ = value;
}

// -------------------------------------------------------------------

// BLPinGetAutoValidateStateRes

// required int32 nState = 1;
inline bool BLPinGetAutoValidateStateRes::has_nstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinGetAutoValidateStateRes::set_has_nstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinGetAutoValidateStateRes::clear_has_nstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinGetAutoValidateStateRes::clear_nstate() {
  nstate_ = 0;
  clear_has_nstate();
}
inline ::google::protobuf::int32 BLPinGetAutoValidateStateRes::nstate() const {
  return nstate_;
}
inline void BLPinGetAutoValidateStateRes::set_nstate(::google::protobuf::int32 value) {
  set_has_nstate();
  nstate_ = value;
}

// -------------------------------------------------------------------

// BLPinSetAutoValidateStateReq

// required int32 nState = 1;
inline bool BLPinSetAutoValidateStateReq::has_nstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BLPinSetAutoValidateStateReq::set_has_nstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BLPinSetAutoValidateStateReq::clear_has_nstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BLPinSetAutoValidateStateReq::clear_nstate() {
  nstate_ = 0;
  clear_has_nstate();
}
inline ::google::protobuf::int32 BLPinSetAutoValidateStateReq::nstate() const {
  return nstate_;
}
inline void BLPinSetAutoValidateStateReq::set_nstate(::google::protobuf::int32 value) {
  set_has_nstate();
  nstate_ = value;
}

// required string strPin = 2;
inline bool BLPinSetAutoValidateStateReq::has_strpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BLPinSetAutoValidateStateReq::set_has_strpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BLPinSetAutoValidateStateReq::clear_has_strpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BLPinSetAutoValidateStateReq::clear_strpin() {
  if (strpin_ != &::google::protobuf::internal::kEmptyString) {
    strpin_->clear();
  }
  clear_has_strpin();
}
inline const ::std::string& BLPinSetAutoValidateStateReq::strpin() const {
  return *strpin_;
}
inline void BLPinSetAutoValidateStateReq::set_strpin(const ::std::string& value) {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  strpin_->assign(value);
}
inline void BLPinSetAutoValidateStateReq::set_strpin(const char* value) {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  strpin_->assign(value);
}
inline void BLPinSetAutoValidateStateReq::set_strpin(const char* value, size_t size) {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  strpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BLPinSetAutoValidateStateReq::mutable_strpin() {
  set_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    strpin_ = new ::std::string;
  }
  return strpin_;
}
inline ::std::string* BLPinSetAutoValidateStateReq::release_strpin() {
  clear_has_strpin();
  if (strpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strpin_;
    strpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PinMessages

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pin_5fmessages_2eproto__INCLUDED
